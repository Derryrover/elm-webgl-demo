var _elm_lang$elm_architecture_tutorial$FragmentShader$fragmentShader = {'src': '\n\nprecision mediump float;\n\nuniform float shade; // needed?\n\nvarying vec3 vColor;\nvarying vec3 vTransformedNormal;\nvarying vec4 vPosition;\n\nvoid main () {\n\n    vec3 normal = normalize(vTransformedNormal);\n    vec3 eyeDirection = normalize( vPosition.xyz - vec3(0.0,0.0,5.0) );\n\n    vec3 ambientLight = vec3(0.6, 0.6, 0.6);\n    vec3 pointLightingColor = vec3(0.7, 0.7, 0.7);\n    vec3 pointLightingSpecularColor = vec3(0.3, 0.3, 0.3);\n    float materialShininess = 2.0;\n\n\n    vec3 lightDirection = vec3(0.0, 0.0, 5.0);\n    //vec3 relativeLightDirection = normalize( vPosition.xyz - lightDirection );\n    vec3 relativeLightDirection = normalize( vPosition.xyz - lightDirection);\n\n    //vec3 reflectionDirection = reflect(relativeLightDirection, normal); // original\n    vec3 reflectionDirection = reflect(-relativeLightDirection, normal); // original\n    //vec3 reflectionDirection = reflect(lightDirection, normal);\n\n    float specularLightWeighting = pow(max(dot(reflectionDirection, eyeDirection), 0.0), materialShininess);\n\n\n    float directionalLightWeighting = max(dot(normal, -relativeLightDirection), 0.0);\n    //float directionalLightWeighting = max(dot(normal, relativeLightDirection), 0.0);\n    //highp vec3 lightWeighting = ambientLight + pointLightingColor * directionalLightWeighting + specularLightWeighting * pointLightingSpecularColor;\n    //highp vec3 lightWeighting = ambientLight + specularLightWeighting * pointLightingSpecularColor;\n\n    highp vec3 lightWeighting = ambientLight + pointLightingColor * directionalLightWeighting;\n    //gl_FragColor = vec4(vColor * lightWeighting, 1.0);\n    gl_FragColor = vec4((vColor * lightWeighting+specularLightWeighting * pointLightingSpecularColor), 1.0);\n    //gl_FragColor = vec4(1.0,1.0,1.0,1.0);\n\n\n\n\n}\n\n'};
